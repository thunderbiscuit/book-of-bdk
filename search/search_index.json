{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The Bitcoin Development Kit","text":"<p>The Bitcoin Development Kit (BDK) project was created to provide well engineered and reviewed components for building bitcoin-based applications.</p> <p>The core components of BDK are written in the Rust language and live in the <code>bitcoindevkit/bdk</code> repository. The core BDK components are built upon the excellent <code>rust-bitcoin</code> and <code>rust-miniscript</code> crates.</p> <p>The BDK team also maintains the <code>bitcoindevkit/bdk-ffi</code> repository which provide cross-platform versions of the high level BDK APIs. Platforms currently supported by the BDK team include: Kotlin (Android, Linux, macOS), Swift (iOS, macOS), and Python (Linux, macOS, Windows). There are also various 3rd party supported bindings for other languages, including Flutter, ReactNative, and JavaScript (WASM bindings for Browser/Node/ReactNative).</p> <p>Warning</p> <p>The <code>bitcoindevkit/bdk-ffi</code> project has not yet been updated to use the new <code>BDK 1.0</code> crates. For current status and timeline for bdk-ffi, see the <code>bdk-ffi</code> project repository.</p>"},{"location":"architecture/design/","title":"Design of the BDK Ecosystem","text":"<p>The pages in this section intend to speak to why the BDK crates are designed the way they are, and the relationship between them.</p>"},{"location":"cookbook/full-wallet/","title":"Full Wallet Example","text":"<p>This page illustrates core wallet functionality, including:</p> <ul> <li>Generating descriptors</li> <li>Wallet creation, persistence, and loading</li> <li>Full scan and light weight sync</li> <li>Creating and broadcasting a transaction</li> </ul> <p>Tip</p> <p>The logic for this page is split between 2 separate examples in the examples source code. One to create descriptors and a second for everything else. If you are following along with the code examples you will need to copy and paste your private descriptors you get from the first example into the second. We leave descriptor creation in a separate example because bdk does not handle private descriptor (or private key) storage, that is up to the wallet developer.</p>"},{"location":"cookbook/full-wallet/#generating-descriptors","title":"Generating Descriptors","text":"<p>First we create signet descriptors for our wallet.</p> examples/rust/descriptors/src/main.rs<pre><code>let mut seed: [u8; 32] = [0u8; 32];\nrand::thread_rng().fill_bytes(&amp;mut seed);\n\nlet network: Network = Network::Signet;\nlet xprv: Xpriv = Xpriv::new_master(network, &amp;seed).unwrap();\nprintln!(\"Generated Master Private Key:\\n{}\\nWarning: be very careful with private keys when using MainNet! We are logging these values for convenience only because this is an example on SigNet.\\n\", xprv);\n\nlet (descriptor, key_map, _) = Bip86(xprv, KeychainKind::External)\n    .build(Network::Signet)\n    .expect(\"Failed to build external descriptor\");\n\nlet (change_descriptor, change_key_map, _) = Bip86(xprv, KeychainKind::Internal)\n    .build(Network::Signet)\n    .expect(\"Failed to build internal descriptor\");\n\nlet descriptor_string_priv = descriptor.to_string_with_secret(&amp;key_map);\nlet change_descriptor_string_priv = change_descriptor.to_string_with_secret(&amp;change_key_map);\n</code></pre> <p>Notice we are creating private descriptors here in order to sign transactions later on.</p>"},{"location":"cookbook/full-wallet/#full-scan-and-address-generation-first-run","title":"Full Scan and Address Generation (First Run)","text":"<p>Next, lets use those descriptors to load up our wallet. Replace the placeholder descriptors in the <code>full-wallet</code> example with your private descriptors:</p> examples/rust/full-wallet/src/main.rs<pre><code>const DESCRIPTOR_PRIVATE_EXTERNAL: &amp;str = \"[your private external descriptor here ...]\";\nconst DESCRIPTOR_PRIVATE_INTERNAL: &amp;str = \"[your private internal descriptor here ...]\";\n// Example private descriptors\n// const DESCRIPTOR_PRIVATE_EXTERNAL: &amp;str = \"tr(tprv8ZgxMBicQKsPdJuLWWArdBsWjqDA3W5WoREnfdgKEcCQB1FMKfSoaFz9JHZU71HwXAqTsjHripkLM62kUQar14SDD8brsmhFKqVUPXGrZLc/86'/1'/0'/0/*)#fv8tutn2\";\n// const DESCRIPTOR_PRIVATE_INTERNAL: &amp;str = \"tr(tprv8ZgxMBicQKsPdJuLWWArdBsWjqDA3W5WoREnfdgKEcCQB1FMKfSoaFz9JHZU71HwXAqTsjHripkLM62kUQar14SDD8brsmhFKqVUPXGrZLc/86'/1'/0'/1/*)#ccz2p7rj\";\n</code></pre> <p>We are going to run this example twice. On the first run it will do a full scan for your wallet, persist that chain data, generate a new address for you, and display your current wallet balance, it will then attempt to build a transaction, but will fail becuase we don't have any funds yet. We will use the new address (from the first run) to request funds from the Mutinynet faucet so we can build a transaction on the second run. On the second run it will load the data from the previous run, do a light weight sync to check for updates (no need to repeat the full scan), and then build and broadcast a transaction. Let's go through this step by step.</p> examples/rust/full-wallet/src/main.rs<pre><code>let mut conn = Connection::open(DB_PATH)?;\n\nlet wallet_opt = Wallet::load()\n    .descriptor(KeychainKind::External, Some(DESCRIPTOR_PRIVATE_EXTERNAL))\n    .descriptor(KeychainKind::Internal, Some(DESCRIPTOR_PRIVATE_INTERNAL))\n    .extract_keys()\n    .check_network(Network::Signet)\n    .load_wallet(&amp;mut conn)?;\n\nlet (mut wallet, is_new_wallet) = if let Some(loaded_wallet) = wallet_opt {\n    (loaded_wallet, false)\n} else {\n    (\n        Wallet::create(DESCRIPTOR_PRIVATE_EXTERNAL, DESCRIPTOR_PRIVATE_INTERNAL)\n            .network(Network::Signet)\n            .create_wallet(&amp;mut conn)?,\n        true,\n    )\n};\n</code></pre> <p>In the quickstart example we simply used an in-memory wallet, with no persistence. But here we are saving wallet data to a file. Notice that we are providing our private descriptors during wallet load. This is because bdk never stores private keys, that responsibility is on the wallet developer (you). The data we are loading here does not include the private keys, but we want our wallet to have signing capabilities, so we need to provide our private descriptors during wallet load. If we get a wallet back from the load attempt, we'll use that, otherwise we'll create a new one. Since this is our first run nothing will be loaded and a new wallet will be created.</p> examples/rust/full-wallet/src/main.rs<pre><code>let client: esplora_client::BlockingClient =\n    Builder::new(\"https://mutinynet.com/api\").build_blocking();\n// Sync the wallet\nif is_new_wallet {\n    // Perform a full scan\n    println!(\"Performing full scan...\");\n    let full_scan_request: FullScanRequestBuilder&lt;KeychainKind&gt; = wallet.start_full_scan();\n    let update: FullScanResponse&lt;KeychainKind&gt; =\n        client.full_scan(full_scan_request, STOP_GAP, PARALLEL_REQUESTS)?;\n    wallet.apply_update(update).unwrap();\n} else {\n    // Perform a regular sync\n    println!(\"Performing regular sync...\");\n    let sync_request: SyncRequestBuilder&lt;(KeychainKind, u32)&gt; =\n        wallet.start_sync_with_revealed_spks();\n    let update: SyncResponse = client.sync(sync_request, PARALLEL_REQUESTS)?;\n    wallet.apply_update(update).unwrap();\n};\nwallet.persist(&amp;mut conn)?;\n</code></pre> <p>Next we'll fetch data from our blockchain client. On the first run, we don't yet have any data, so we need to do a full scan. We then persist the data from the scan. Finally, we'll print out an address that we can use to request funds. You should also see the current balance printed out, it should be 0 since this is a brand new wallet. Note that we persist the wallet after generating the new address; this is to avoid re-using the same address as that would compromise our privacy (on subsequent runs you'll notice the address index incremented).</p> examples/rust/full-wallet/src/main.rs<pre><code>// Reveal a new address from your external keychain\nlet address: AddressInfo = wallet.reveal_next_address(KeychainKind::External);\nprintln!(\n    \"Generated address {} at index {}\",\n    address.address, address.index\n);\nwallet.persist(&amp;mut conn)?;\n</code></pre> <p>The process will then error out, indicating we don't have enough funds to send a transaction.</p>"},{"location":"cookbook/full-wallet/#request-satoshis-from-the-mutinynet-faucet","title":"Request satoshis from the Mutinynet faucet","text":"<p>We can now use our new address to request some sats from the Mutinynet faucet. After requesting sats, you can view the transaction in their Mempool Explorer instance (click the link on the faucet confirmation page or put the txid in the search bar of the mempool explorer). After a minute or so you should see the transaction confirmed. We can also re-run the <code>full-wallet</code> example and see that our wallet now has some funds!</p>"},{"location":"cookbook/full-wallet/#load-sync-and-send-a-transaction-second-run","title":"Load, Sync, and Send a Transaction (Second Run)","text":"<p>Now that we have some funds, we can re-run the <code>full-wallet</code> example. Since we persisted data from the previous run, this time our wallet will be loaded. You do not need to provide descriptors to load wallet data, however, if you don't you will not have signing capabilities, so here we do provide our private descriptors in the loading process:</p> examples/rust/full-wallet/src/main.rs<pre><code>let mut conn = Connection::open(DB_PATH)?;\n\nlet wallet_opt = Wallet::load()\n    .descriptor(KeychainKind::External, Some(DESCRIPTOR_PRIVATE_EXTERNAL))\n    .descriptor(KeychainKind::Internal, Some(DESCRIPTOR_PRIVATE_INTERNAL))\n    .extract_keys()\n    .check_network(Network::Signet)\n    .load_wallet(&amp;mut conn)?;\n\nlet (mut wallet, is_new_wallet) = if let Some(loaded_wallet) = wallet_opt {\n    (loaded_wallet, false)\n} else {\n    (\n        Wallet::create(DESCRIPTOR_PRIVATE_EXTERNAL, DESCRIPTOR_PRIVATE_INTERNAL)\n            .network(Network::Signet)\n            .create_wallet(&amp;mut conn)?,\n        true,\n    )\n};\n</code></pre> <p>Since we already have some data from the previous run, it will not do a full scan, but only a sync which is faster and less data intensive.</p> examples/rust/full-wallet/src/main.rs<pre><code>let client: esplora_client::BlockingClient =\n    Builder::new(\"https://mutinynet.com/api\").build_blocking();\n// Sync the wallet\nif is_new_wallet {\n    // Perform a full scan\n    println!(\"Performing full scan...\");\n    let full_scan_request: FullScanRequestBuilder&lt;KeychainKind&gt; = wallet.start_full_scan();\n    let update: FullScanResponse&lt;KeychainKind&gt; =\n        client.full_scan(full_scan_request, STOP_GAP, PARALLEL_REQUESTS)?;\n    wallet.apply_update(update).unwrap();\n} else {\n    // Perform a regular sync\n    println!(\"Performing regular sync...\");\n    let sync_request: SyncRequestBuilder&lt;(KeychainKind, u32)&gt; =\n        wallet.start_sync_with_revealed_spks();\n    let update: SyncResponse = client.sync(sync_request, PARALLEL_REQUESTS)?;\n    wallet.apply_update(update).unwrap();\n};\nwallet.persist(&amp;mut conn)?;\n</code></pre> <p>Now that we have funds, let's prepare to send a transaction. We need to decide where to send the funds and how much to send.We will send funds back to the mutiny faucet return address. It's good practice to send test sats back to the faucet when you're done using them.</p> examples/rust/full-wallet/src/main.rs<pre><code>// Use the Mutinynet faucet return address\nlet faucet_address = Address::from_str(\"tb1qd28npep0s8frcm3y7dxqajkcy2m40eysplyr9v\")\n    .unwrap()\n    .require_network(Network::Signet)\n    .unwrap();\n\nlet send_amount: Amount = Amount::from_sat(5000);\n</code></pre> <p>Here we are preparing to send 5000 sats back to the mutiny faucet, so you'll need to request at more sats than that or change this value (it's good practice to send test sats back to the faucet when you're done using them).</p> <p>Finally we are ready to build, sign, and broadcast the transaction:</p> examples/rust/transaction/src/main.rs<pre><code>// Transaction Logic\nlet mut tx_builder = wallet.build_tx();\ntx_builder.fee_rate(FeeRate::from_sat_per_vb(4).unwrap());\ntx_builder.add_recipient(faucet_address.script_pubkey(), send_amount);\n\nlet mut psbt = tx_builder.finish()?;\nlet finalized = wallet.sign(&amp;mut psbt, SignOptions::default())?;\nassert!(finalized);\n\nlet tx = psbt.extract_tx()?;\nclient.broadcast(&amp;tx)?;\nprintln!(\"Tx broadcasted! Txid: {}\", tx.compute_txid());\n</code></pre> <p>We are manually determining the fee rate to be 4 sat/vb (satoshis per virtual byte).</p> <p>Again we can view the transaction in the Mutinynet explorer or re-run the <code>full-wallet</code> example to see that our wallet has less funds.</p>"},{"location":"cookbook/full-wallet/#drain-the-wallet","title":"Drain the Wallet","text":"<p>When you're done with the test sats that you got from the faucet, you should send the remaining funds back to the faucet by draining the wallet.</p>"},{"location":"cookbook/quickstart/","title":"Quick Start Example","text":"<p>This page provides an overview of how BDK can be leveraged to create and sync a wallet using an Esplora client. You can find working code examples of this workflow in three programming languages: Rust, Swift, and Kotlin. (Note: some additional language bindings are available for BDK, see 3rd Party Bindings)</p>"},{"location":"cookbook/quickstart/#create-a-new-project","title":"Create a new project","text":"RustSwiftKotlin <pre><code>cargo init quickstart\ncd quickstart\n</code></pre> <p><pre><code>swift package init --type executable\n</code></pre> Or, if you're building an iOS app, create a new Swift project in Xcode.</p> <p>Create a new Kotlin project.</p>"},{"location":"cookbook/quickstart/#add-required-dependencies","title":"Add required dependencies","text":"RustSwiftKotlin Cargo.toml<pre><code>[package]\nname = \"quickstart\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nbdk_wallet = { version = \"1.0.0\" }\nbdk_esplora = { version = \"0.20.1\", features = [\"blocking\"] }\n</code></pre> <p>Package.swift<pre><code>// swift-tools-version: 5.10\n\nimport PackageDescription\n\nlet package = Package(\n    name: \"QuickstartExample\",\n    platforms: [\n        .macOS(.v12)\n    ],\n    dependencies: [\n        .package(url: \"https://github.com/bitcoindevkit/bdk-swift\", from: \"1.0.0-beta.5\")\n    ],\n    targets: [\n        .executableTarget(\n            name: \"QuickstartExample\",\n            dependencies: [\n                .product(name: \"BitcoinDevKit\", package: \"bdk-swift\")\n            ],\n            path: \"Sources\"\n        )\n    ]\n)\n</code></pre> Or, if you're building an iOS app:</p> <ol> <li>From the Xcode File menu, select Add Package Dependencies...</li> <li>Enter <code>https://github.com/bitcoindevkit/bdk-swift</code> into the package repository URL search field and bdk-swift should come up</li> <li>For the Dependency Rule select <code>Exact Version</code>, enter the version number (same as Package.swift) and click Add Package</li> </ol> build.gradle<pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    // for jvm\n    implementation 'org.bitcoindevkit:bdk-jvm:&lt;version&gt;'\n    // OR for android\n    implementation 'org.bitcoindevkit:bdk-android:&lt;version&gt;'\n}\n</code></pre>"},{"location":"cookbook/quickstart/#create-a-wallet-sync-it-and-display-the-balance","title":"Create a wallet, sync it and display the balance","text":"<p>We'll give a breakdown of the key pieces of this code in the next section.</p> RustSwiftKotlin examples/rust/quickstart/src/main.rs<pre><code>use bdk_esplora::esplora_client;\nuse bdk_esplora::esplora_client::Builder;\nuse bdk_esplora::EsploraExt;\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::chain::spk_client::{FullScanRequestBuilder, FullScanResponse};\nuse bdk_wallet::AddressInfo;\nuse bdk_wallet::KeychainKind;\nuse bdk_wallet::Wallet;\n\nconst STOP_GAP: usize = 50;\nconst PARALLEL_REQUESTS: usize = 1;\n\nfn main() {\n    let descriptor: &amp;str = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\";\n    let change_descriptor: &amp;str = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\";\n\n    // Create the wallet\n    let mut wallet: Wallet = Wallet::create(descriptor, change_descriptor)\n        .network(Network::Signet)\n        .create_wallet_no_persist()\n        .unwrap();\n\n    // Sync the wallet\n    let client: esplora_client::BlockingClient =\n        Builder::new(\"https://mutinynet.com/api\").build_blocking();\n\n    println!(\"Syncing wallet...\");\n    let full_scan_request: FullScanRequestBuilder&lt;KeychainKind&gt; = wallet.start_full_scan();\n    let update: FullScanResponse&lt;KeychainKind&gt; = client\n        .full_scan(full_scan_request, STOP_GAP, PARALLEL_REQUESTS)\n        .unwrap();\n    // Apply the update from the full scan to the wallet\n    wallet.apply_update(update).unwrap();\n\n    let balance = wallet.balance();\n    println!(\"Wallet balance: {} sat\", balance.total().to_sat());\n\n    // Reveal a new address from your external keychain\n    let address: AddressInfo = wallet.reveal_next_address(KeychainKind::External);\n    println!(\n        \"Generated address {} at index {}\",\n        address.address, address.index\n    );\n}\n</code></pre> examples/swift/quickstart/Sources/main.swift<pre><code>import BitcoinDevKit\n\nlet descriptor = try Descriptor(descriptor: \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\", network: Network.signet)\nlet changeDescriptor = try Descriptor(descriptor: \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\", network: Network.signet)\n\nlet wallet = try Wallet(\n    descriptor: descriptor,\n    changeDescriptor: changeDescriptor,\n    network: Network.signet,\n    connection: Connection.newInMemory()\n)\n\nlet addressInfo = wallet.revealNextAddress(keychain: .external)\nprint(\"Generated address \\(addressInfo.address) at index \\(addressInfo.index)\")\n\nlet esploraClient = EsploraClient(url: \"https://mutinynet.com/api\")\n\nlet syncRequest = try wallet.startSyncWithRevealedSpks().build()\nlet update = try esploraClient.sync(\n    syncRequest: syncRequest,\n    parallelRequests: UInt64(5)\n)\ntry wallet.applyUpdate(update: update)\nlet balance = wallet.balance()\nprint(\"Wallet balance: \\(balance.total.toSat()) sat\")\n</code></pre> examples/kotlin/quickstart/main.kt<pre><code>val descriptor = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\"\nval changeDescriptor = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\"\n\nval wallet = Wallet(\n  descriptor, \n  changeDescriptor, \n  Network.SIGNET\n)\n\nval addressInfo = wallet.revealNextAddress(KeychainKind.EXTERNAL)\nprintln(\"Generated address ${addressInfo.address} at index ${addressInfo.index}\")\n\nval esploraClient: EsploraClient = EsploraClient(\"https://mutinynet.com/api\")\n\nval syncRequest = wallet.startSyncWithRevealedSpks()\nval update = try esploraClient.sync(\n    syncRequest,\n    5uL\n)\nwallet.applyUpdate(update)\nval balance = wallet.balance()\nprintln(\"Wallet balance: ${balance.total()} sat\")\n</code></pre>"},{"location":"cookbook/quickstart/#build-and-run","title":"Build and run:","text":"<p>The wallet will take a few seconds to sync, then you should see the wallet balance printed in the terminal.</p> RustSwiftKotlin <pre><code>cargo build\ncargo run\n</code></pre> <p><pre><code>swift run\n</code></pre> Or run the project in Xcode.</p> <p>Run the project in your IDE.</p>"},{"location":"cookbook/quickstart/#lets-take-a-closer-look","title":"Let's take a closer look","text":""},{"location":"cookbook/quickstart/#descriptors","title":"Descriptors","text":"<p>First we need some descriptors to instantiate our wallet. In this example we use public key descriptors to simply display the balance of a wallet. To sign transactions you will need to use a wallet that is instantiated with private key descriptors. Refer to the Creating Descriptors page for information on how to generate your own private descriptors.</p> RustSwiftKotlin <pre><code>let descriptor: &amp;str = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\";\nlet change_descriptor: &amp;str = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\";\n</code></pre> <pre><code>let descriptor = try Descriptor(descriptor: \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\", network: Network.signet)\nlet changeDescriptor = try Descriptor(descriptor: \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\", network: Network.signet)\n</code></pre> <pre><code>val descriptor = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\"\nval changeDescriptor = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\"\n</code></pre> <p>These are taproot <code>tr()</code> descriptors using public keys on testnet (or signet) <code>tpub</code> as described in BIP86. The <code>descriptor</code> is an HD wallet with a path for generating addresses to give out externally for payment. We also have a second <code>change_descriptor</code> that we can use to generate addresses to pay ourselves change when sending payments (remember that UTXOs must be spent in full, so you often need to make change).</p>"},{"location":"cookbook/quickstart/#blockchain-client-and-network","title":"Blockchain Client and Network","text":"<p>This example is using an Esplora client on the Mutinynet Signet network.</p> RustSwiftKotlin <pre><code>let client: esplora_client::BlockingClient =\n    Builder::new(\"https://mutinynet.com/api\").build_blocking();\n</code></pre> <pre><code>let esploraClient = EsploraClient(url: \"https://mutinynet.com/api\")\n</code></pre> <pre><code>val esploraClient: EsploraClient = EsploraClient(\"https://mutinynet.com/api\")\n</code></pre> <p>Other options for blockchain clients include running an Electrum light wallet or using RPC on a bitcoind fullnode. We are using Esplora in this example.</p> <p>This example also used the Signet network. You may alternatively want to run this example wallet using a locally hosted Regtest network. The details of how to set that up are beyond the scope of this example.</p>"},{"location":"cookbook/quickstart/#scan","title":"Scan","text":"<p>Once we have our wallet setup and connected to the network, we scan the network to detect UTXOs relevant to our wallet.</p> RustSwiftKotlin <pre><code>let full_scan_request: FullScanRequestBuilder&lt;KeychainKind&gt; = wallet.start_full_scan();\nlet update: FullScanResponse&lt;KeychainKind&gt; = client\n    .full_scan(full_scan_request, STOP_GAP, PARALLEL_REQUESTS)\n    .unwrap();\n// Apply the update from the full scan to the wallet\nwallet.apply_update(update).unwrap();\n\nlet balance = wallet.balance();\nprintln!(\"Wallet balance: {} sat\", balance.total().to_sat());\n</code></pre> <pre><code>let syncRequest = try wallet.startSyncWithRevealedSpks().build()\nlet update = try esploraClient.sync(\n    syncRequest: syncRequest,\n    parallelRequests: UInt64(5)\n)\ntry wallet.applyUpdate(update: update)\nlet balance = wallet.balance()\nprint(\"Wallet balance: \\(balance.total.toSat()) sat\")\n</code></pre> <pre><code>val syncRequest = wallet.startSyncWithRevealedSpks()\nval update = try esploraClient.sync(\n    syncRequest,\n    5uL\n)\nwallet.applyUpdate(update)\nval balance = wallet.balance()\nprintln(\"Wallet balance: ${balance.total()} sat\")\n</code></pre> <p>This scanning process is detailed on the Full Scan vs Sync page. The scanning process checks child pubkeys for the descriptors specified in the wallet to detect UTXOs that are relevant to the wallet. That data is then applied to the wallet.</p>"},{"location":"cookbook/quickstart/#display-wallet-balance","title":"Display Wallet Balance","text":"<p>Finally we can print the <code>wallet.balance()</code> to see how many sats we have available based on the information gathered in the scanning process.</p>"},{"location":"cookbook/wasm/","title":"WASM Example","text":"<p>WASM bindings can be used to access rust code from virtually any JavaScript environment: browsers, Node.js, ReactNative, etc.</p> <p>Info</p> <p>This page details how to build a custom WASM package that uses BDK rust crate under the hood. If you want an out of the box solution for JS(WASM) bindings for BDK which don't require writing any rust code, see the WASM section on the 3rd Party Bindings page for a pre-packaged npm module.</p> <p>Because rust can compile to WASM, it is possible to use BDK in the browser. However, there are a few limitations to keep in mind which will be highlighted in this example. That being said, there are perfectly viable work-arounds for these limitations that should suffice for most use cases.</p> <p>Warning</p> <p>There are several limitations to using BDK in WASM. Basically any functionality that requires OS access is not directly available in WASM and must therefore be handled in JavaScript. Some key limitations include:</p> <ul> <li>No access to the file system</li> <li>No access to the system time</li> <li>Network access is limited to http(s)</li> </ul>"},{"location":"cookbook/wasm/#wasm-considerations-overview","title":"WASM Considerations Overview","text":""},{"location":"cookbook/wasm/#no-access-to-the-file-system","title":"No access to the file system","text":"<p>With no direct access to the file system, persistence cannot be handled by BDK directly. Instead, an in memory wallet must be used in the WASM environment, and the data must be exported through a binding to the JavaScript environment to be persisted.</p>"},{"location":"cookbook/wasm/#no-access-to-the-system-time","title":"No access to the system time","text":"<p>Any function that requires system time, such as any sort of timestamp, must access system time through a wasm binding to the JavaScript environment. This means some BDK functions that are commonly used in rust won't work in WASM and instead an alternate rust function that takes a timestamp as an argument must be used (I.E. instead of <code>.apply_update()</code> we must use <code>.apply_update_at()</code>).</p>"},{"location":"cookbook/wasm/#network-access-is-limited-to-https","title":"Network access is limited to http(s)","text":"<p>This effectively means that the blockchain client must be an Esplora instance. Both RPC and Electrum clients require sockets and will not work for BDK in a WASM environment out of the box.</p>"},{"location":"cookbook/wasm/#troubleshooting","title":"Troubleshooting","text":"<p>WASM errors can be quite cryptic, so it's important to understand the limitations of the WASM environment. One common error you might see while running a BDK function through a WASM binding in the browser is <code>unreachable</code>. This error likely will not point you to the actual BDK function that is causing the error. Instead you need to be able to assess whether you are calling a function that uses a rust feature that is unsupported in the WASM environment. For example, if you do a scan and then try to use <code>.apply_update()</code> you will get an <code>unreachable</code> error. This is because <code>.apply_update()</code> requires system time, which is not available in the WASM environment. Instead you need to use <code>.apply_update_at()</code> which takes an explicit timestamp as an argument (see below).</p>"},{"location":"cookbook/wasm/#wasm-app-example","title":"WASM App Example","text":"<p>In this example we will cover basic BDK functionality in a WASM environment. We will show code snippets for both the rust and JavaScript necessary to create a custom WASM package, and we will highlight the key differences from the plain rust examples (due to WASM limitations).</p> <p>Info</p> <p>The WASM example code is split into two project folders: a rust project that uses wasm-pack to compile rust code to WASM files, and a JavaScript project that pulls the WASM project as a dependency. The JS project represents the web app and the rust project is used to generate an npm module.</p>"},{"location":"cookbook/wasm/#initializing-a-wallet","title":"Initializing a Wallet","text":"<p>From JS running in our browser, first we need our descriptors:</p> <pre><code>const externalDescriptor = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\";\nconst internalDescriptor = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\";\n</code></pre> <p>Then we can initialize the wallet, we'll use some conditional logic here to either 1) create a new wallet and perform a full scan, or 2) load a wallet from stored data and sync it to get recent updates.</p> <pre><code>let walletDataString = Store.load();\nconsole.log(\"Wallet data:\", walletDataString);\n\nlet wallet;\nif (!walletDataString) {\n    console.log(\"Creating new wallet\");\n    wallet = new WalletWrapper(\n        \"signet\",\n        externalDescriptor,\n        internalDescriptor,\n        \"https://mutinynet.com/api\"\n    );\n\n    console.log(\"Performing Full Scan...\");\n    await wallet.scan(2);\n\n    const stagedDataString = wallet.take_staged();\n    console.log(\"Staged:\", stagedDataString);\n\n    Store.save(stagedDataString);\n    console.log(\"Wallet data saved to local storage\");\n    walletDataString = stagedDataString;\n} else {\n    console.log(\"Loading wallet\");\n    wallet = WalletWrapper.load(\n        walletDataString,\n        \"https://mutinynet.com/api\",\n        externalDescriptor,\n        internalDescriptor\n    );\n\n    console.log(\"Syncing...\");\n    await wallet.sync(2);\n\n    const stagedDataString = wallet.take_staged();\n    console.log(\"Staged:\", stagedDataString);\n\n    Store.save(stagedDataString);\n    console.log(\"Wallet data saved to local storage\");\n}\n</code></pre>"},{"location":"cookbook/wasm/#network-consideration","title":"Network Consideration","text":"<p>Notice we are including blockchain client details in wallet initialization (Signet, and the esplora url). This is because we are forced to use esplora, so we may as well initialize the client at the same time as the wallet.</p> <p>Here is the relevant rust code:</p> <pre><code>#[wasm_bindgen(constructor)]\npub fn new(\n    network: String,\n    external_descriptor: String,\n    internal_descriptor: String,\n    esplora_url: String,\n) -&gt; Result&lt;WalletWrapper, String&gt; {\n    let network = match network.as_str() {\n        \"mainnet\" =&gt; Network::Bitcoin,\n        \"testnet\" =&gt; Network::Testnet,\n        \"testnet4\" =&gt; Network::Testnet4,\n        \"signet\" =&gt; Network::Signet,\n        \"regtest\" =&gt; Network::Regtest,\n        _ =&gt; return Err(\"Invalid network\".into()),\n    };\n\n    let wallet_opt = Wallet::load()\n        .descriptor(KeychainKind::External, Some(external_descriptor.clone()))\n        .descriptor(KeychainKind::Internal, Some(internal_descriptor.clone()))\n        .extract_keys()\n        .check_network(network)\n        .load_wallet_no_persist(ChangeSet::default())\n        .map_err(|e| format!(\"{:?}\", e))?;\n\n    let wallet = match wallet_opt {\n        Some(wallet) =&gt; wallet,\n        None =&gt; Wallet::create(external_descriptor, internal_descriptor)\n            .network(network)\n            .create_wallet_no_persist()\n            .map_err(|e| format!(\"{:?}\", e))?,\n    };\n\n    let client = esplora_client::Builder::new(&amp;esplora_url)\n        .max_retries(6)\n        .build_async_with_sleeper()\n        .map_err(|e| format!(\"{:?}\", e))?;\n\n    Ok(WalletWrapper { wallet, client })\n}\n\npub fn load(\n    changeset_str: &amp;str,\n    url: &amp;str,\n    external_descriptor: &amp;str,\n    internal_descriptor: &amp;str,\n) -&gt; JsResult&lt;WalletWrapper&gt; {\n    let changeset_value: Value = serde_json::from_str(changeset_str)?;\n    let changeset: ChangeSet = serde_json::from_value(changeset_value)?;\n\n    let wallet_opt = Wallet::load()\n        .descriptor(\n            KeychainKind::External,\n            Some(external_descriptor.to_string()),\n        )\n        .descriptor(\n            KeychainKind::Internal,\n            Some(internal_descriptor.to_string()),\n        )\n        .extract_keys()\n        .load_wallet_no_persist(changeset)?;\n\n    let wallet = match wallet_opt {\n        Some(wallet) =&gt; wallet,\n        None =&gt; return Err(JsError::new(\"Failed to load wallet, check the changeset\")),\n    };\n\n    let client = esplora_client::Builder::new(&amp;url).build_async_with_sleeper()?;\n\n    Ok(WalletWrapper { wallet, client })\n}\n\npub async fn scan(&amp;mut self, stop_gap: usize) -&gt; Result&lt;(), String&gt; {\n    let wallet = &amp;mut self.wallet;\n    let client = &amp;self.client;\n\n    let request = wallet.start_full_scan();\n\n    let update = client\n        .full_scan(request, stop_gap, PARALLEL_REQUESTS)\n        .await\n        .map_err(|e| format!(\"{:?}\", e))?;\n\n    let now = (Date::now() / 1000.0) as u64;\n    wallet\n        .apply_update_at(update, now)\n        .map_err(|e| format!(\"{:?}\", e))?;\n\n    Ok(())\n}\n\npub async fn sync(&amp;mut self, parallel_requests: usize) -&gt; JsResult&lt;()&gt; {\n    let request = self.wallet.start_sync_with_revealed_spks();\n    let update = self.client.sync(request, parallel_requests).await?;\n\n    let now = (Date::now() / 1000.0) as u64;\n    self.wallet.apply_update_at(update, now)?;\n\n    Ok(())\n}\n</code></pre> <p>The first time you load the page in your browser, you should see info in the console confirming that a new wallet was created and a full scan was performed. If you then reload the page you should see that the wallet was loaded from the previously saved data and a sync was performed instead of a full scan.</p>"},{"location":"cookbook/wasm/#system-time-consideration","title":"System Time Consideration","text":"<p>Notice we are using a JS binding to access system time with <code>js_sys::Date::now()</code>, then passing that timestamp to the <code>apply_update_at()</code> function, rather than attempting to use the <code>.apply_update()</code> function which would throw an error.</p>"},{"location":"cookbook/wasm/#persistence-consideration","title":"Persistence Consideration","text":"<p>Also notice we are using an in-memory wallet with <code>.create_wallet_no_persist()</code>. If you try to use persistence through file or database you will get an error because those features require OS access. Instead we have to create a binding to pass the wallet data to the JavaScript environment where we can handle persistence. We have a method to grab the new updates to the wallet data, and a method to merge new updates with existing data. With this simple approach to persistence we must always merge existing data with the updates unless there is no existing data (i.e. after new wallet creation). The rust side methods to extract the wallet data are:</p> <pre><code>pub fn take_staged(&amp;mut self) -&gt; JsResult&lt;String&gt; {\n    match self.wallet.take_staged() {\n        Some(changeset) =&gt; {\n            let value = serde_json::to_value(&amp;changeset)?;\n            Ok(serde_json::to_string(&amp;value)?)\n        }\n        None =&gt; Ok(\"null\".to_string()),\n    }\n}\n\npub fn take_merged(&amp;mut self, previous: String) -&gt; JsResult&lt;String&gt; {\n    match self.wallet.take_staged() {\n        Some(curr_changeset) =&gt; {\n            let previous_value: Value = serde_json::from_str(&amp;previous)?;\n            let mut previous_changeset: ChangeSet = serde_json::from_value(previous_value)?;\n            previous_changeset.merge(curr_changeset);\n            let final_value = serde_json::to_value(&amp;previous_changeset)?;\n            Ok(serde_json::to_string(&amp;final_value)?)\n        }\n        None =&gt; Ok(\"null\".to_string()),\n    }\n}\n</code></pre> <p>Notice we're converting the wallet data to a JSON string so that it plays nicely with WASM; and on the JS side we'll save our data string with a minimal custom browser store:</p> <pre><code>// simple string storage example\nconst Store = {\n    save: data =&gt; {\n        if (!data) {\n            console.log(\"No data to save\");\n            return;\n        }\n        localStorage.setItem(\"walletData\", data);  // data is already a JSON string\n    },\n    load: () =&gt; {\n        return localStorage.getItem(\"walletData\");  // return the JSON string directly\n    }\n}\n</code></pre> <p>This is just to show an example of how the wallet data can be persisted. We're using local storage here, but in practice a wallet app would generally use cloud storage of some sort since browser local storage tends to be temporary.</p>"},{"location":"cookbook/wasm/#balance-and-addresses","title":"Balance and Addresses","text":"<p>We can now get the balance of our wallet and generate a new address. Here is the JS code:</p> <pre><code>// Test balance\nconsole.log(\"Balance:\", wallet.balance());\n\n// Test address generation\nconsole.log(\"New address:\", wallet.reveal_next_address());\n\n// handle changeset merge on rust side\nconst mergedDataString = wallet.take_merged(walletDataString);\n\nconsole.log(\"Merged:\", mergedDataString);\n\nStore.save(mergedDataString);\nconsole.log(\"new address saved\");\n</code></pre> <p>Here is the rust code that gets called:</p> <pre><code>pub fn balance(&amp;self) -&gt; u64 {\n    let balance = self.wallet.balance();\n    balance.total().to_sat()\n}\n\npub fn reveal_next_address(&amp;mut self) -&gt; String {\n    let address = self.wallet.reveal_next_address(KeychainKind::External);\n\n    address.to_string()\n}\n</code></pre> <p>Notice we call <code>take_merged()</code> and <code>Store.save()</code> after generating a new address so our wallet keeps track of generated addresses (so we don't re-use them). If you reload the browser you can see the generated address value updated along with the index.</p>"},{"location":"cookbook/keys-descriptors/descriptors/","title":"Creating Keys and Descriptors","text":"<p>BDK is a descriptor-first library. This page explores how to build them and how they interact with other standards like BIP-39 recovery phrases.</p> <p>Danger</p> <p>The keys and descriptors used in The Book of BDK are for illustration purposes only; UNDER NO CIRCUMSTANCES should any of the keys or descriptors containing private data be used for real money. Entropy generation should be carried out in a secure environment using cryptographically secure random number generators (CSPRNG).</p>"},{"location":"cookbook/keys-descriptors/descriptors/#using-descriptor-templates","title":"Using descriptor templates","text":"<p>BDK offers utility constructs called descriptor templates, which allow you to build descriptors for the four most common script types (BIP 44/49/84/86) with minimal effort.</p> <p>The following will build and print the full string representation of taproot (BIP-86) internal and external descriptors. We print both the public key descriptors (for HD wallet address generation only) and private key descriptors (for full wallet functionality including transaction signing).</p> <pre><code>use bdk_wallet::bitcoin::bip32::Xpriv;\nuse bdk_wallet::bitcoin::secp256k1::rand;\nuse bdk_wallet::bitcoin::secp256k1::rand::RngCore;\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::template::{Bip86, DescriptorTemplate};\nuse bdk_wallet::KeychainKind;\n\nfn main() {\n    // --8&lt;-- [start:main]\n    let mut seed: [u8; 32] = [0u8; 32];\n    rand::thread_rng().fill_bytes(&amp;mut seed);\n\n    let network: Network = Network::Signet;\n    let xprv: Xpriv = Xpriv::new_master(network, &amp;seed).unwrap();\n    println!(\"Generated Master Private Key:\\n{}\\nWarning: be very careful with private keys when using MainNet! We are logging these values for convenience only because this is an example on SigNet.\\n\", xprv);\n\n    let (descriptor, key_map, _) = Bip86(xprv, KeychainKind::External)\n        .build(Network::Signet)\n        .expect(\"Failed to build external descriptor\");\n\n    let (change_descriptor, change_key_map, _) = Bip86(xprv, KeychainKind::Internal)\n        .build(Network::Signet)\n        .expect(\"Failed to build internal descriptor\");\n\n    let descriptor_string_priv = descriptor.to_string_with_secret(&amp;key_map);\n    let change_descriptor_string_priv = change_descriptor.to_string_with_secret(&amp;change_key_map);\n    // --8&lt;-- [end:main]\n\n    println!(\n        \"----------------  Descriptors  ------------------------------\\nPrivate Key, External:\\n{:?}\\nPrivate Key, Internal:\\n{:?}\\nPublic Key, External:\\n{:?}\\nPublic Key, Internal:\\n{:?}\\n\",\n        descriptor_string_priv, // privkey\n        change_descriptor_string_priv,\n        descriptor.to_string(), // pubkey\n        change_descriptor.to_string()\n    );\n}\n</code></pre>"},{"location":"cookbook/keys-descriptors/seed-phrase/","title":"Recover Descriptors from Seeds","text":"<p>BDK wallets require the use of descriptors, but recovery phrases (also called seed phrases) are a common and popular backup solution. Creating descriptors from a recovery phrase is a common workflow and BDK makes this easy with its descriptor templates, which are offered for common descriptors (BIP 44/49/84/86).</p> <p>Feature Flags</p> <p>The current example requires the feature <code>keys-bip39</code> for <code>bdk_wallet</code>. You can add it with:</p> <pre><code>cargo add bdk_wallet --features=\"keys-bip39\"\n</code></pre>"},{"location":"cookbook/keys-descriptors/seed-phrase/#example","title":"Example","text":"<pre><code>use bdk_wallet::bitcoin::bip32::Xpriv;\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::keys::bip39::Mnemonic;\nuse bdk_wallet::template::{Bip86, DescriptorTemplate};\nuse bdk_wallet::KeychainKind;\n\nconst RECOVERY_PHRASE: &amp;str = \"[your 12 word seed phrase here ...]\";\n// const RECOVERY_PHRASE: &amp;str = \"holiday marble tide globe license stumble rescue antenna monitor sea half sauce\"; // example\n\nfn main() {\n    let mnemonic = Mnemonic::parse(RECOVERY_PHRASE).expect(\"Invalid seed! Be sure to replace the value of RECOVERY_PHRASE with your own 12 word seed phrase.\");\n    let seed = mnemonic.to_seed(\"\");\n    let xprv: Xpriv =\n        Xpriv::new_master(Network::Signet, &amp;seed).expect(\"Failed to create master key\");\n    println!(\"Generated Master Private Key:\\n{}\\nWarning: be very careful with seeds and private keys when using MainNet! We are logging these values for convenience only because this is an example on SigNet.\\n\", xprv);\n\n    let (descriptor, key_map, _) = Bip86(xprv, KeychainKind::External)\n        .build(Network::Signet)\n        .expect(\"Failed to build external descriptor\");\n\n    let (change_descriptor, change_key_map, _) = Bip86(xprv, KeychainKind::Internal)\n        .build(Network::Signet)\n        .expect(\"Failed to build internal descriptor\");\n\n    println!(\n        \"----------------  Descriptors  ------------------------------\\nPrivate Key, External:\\n{:?}\\nPrivate Key, Internal:\\n{:?}\\nPublic Key, External:\\n{:?}\\nPublic Key, Internal:\\n{:?}\\n\",\n        descriptor.to_string_with_secret(&amp;key_map), // privkey\n        change_descriptor.to_string_with_secret(&amp;change_key_map),\n        descriptor.to_string(), // pubkey\n        change_descriptor.to_string()\n    );\n}\n</code></pre>"},{"location":"cookbook/persistence/memory/","title":"In-Memory Wallet","text":"<p>The simplest wallet is one that does not have any persistence. All information about the wallet is held in memory, and will be destroyed upon termination of the process.</p> <p>In-memory implies that the addresses the wallet has revealed, the syncing that has been performed including data on the transaction graph will not persist when the wallet is destroyed, and related operations will need to be performed again.</p> <p>In general, this means performing a <code>full_scan()</code> when starting the wallet, because it has no knowledge of which addresses were given out and which scripts still have balances.</p> <p>See our page on the difference between the full scan and sync operations for more on this topic.</p>"},{"location":"cookbook/persistence/memory/#example","title":"Example","text":"<p>The in-memory wallet does not require any additional dependencies beyond the <code>bdk_wallet</code> dependency:</p> Cargo.toml<pre><code>[dependencies]\nbdk_wallet = { version = \"1.0.0\" }\n</code></pre> <p>To create an in-memory wallet, simply call <code>create_wallet_no_persist()</code> on the <code>Wallet</code> builder:</p> main.rs<pre><code>let mut wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n    .network(Network::Signet)\n    .create_wallet_no_persist()\n    .expect(\"valid wallet\");\n</code></pre> <p></p>"},{"location":"cookbook/persistence/sqlite/","title":"SQLite Database","text":"<p>The SQLite persistence is a great default for many use cases, and is a good place to start if you're not sure which persistence to choose from.</p> <p>By default when using the <code>bdk_wallet</code> library, all information about the wallet is held in memory, and will be destroyed upon termination of the process unless saved to persistence. </p> <p>When information important to the wallet is added to it, the wallet will add it to its staged area. Whenever you want to save this information to persistence, call the <code>Wallet.persist(&amp;mut db)</code>.</p> <p>The operations that affect the wallet and produce a changeset are things like:</p> <ul> <li>Revealing new addresses</li> <li>Sync operations that pick up new UTXOs</li> </ul> <p>Once those things are persisted, upon loading of the database changeset the wallet would be able to rehydrate its TxGraph, which includes UTXOs, transaction history, and latest blocks known to the wallet. This means that a wallet that's been loaded from such a persistence will not require a Full Scan but rather simply a Sync.</p> <p>See our page on the difference between the full scan and sync operations for more on this topic.</p>"},{"location":"cookbook/persistence/sqlite/#example","title":"Example","text":"<p>The sqlite wallet does not require any additional dependencies above the <code>bdk_wallet</code> dependency:</p> Cargo.toml<pre><code>[dependencies]\nbdk_wallet = { version = \"1.0.0\", features = [\"rusqlite\"] }\n</code></pre> <p>To load an existing sqlite-based persisted wallet use <code>Wallet::load()</code>. You may then optionally verify the loaded descriptors match what you expect. If the provided descriptors contain private keys you can also extract these keys into the wallets keystore. Private keys are never stored in the wallet database. You may also verify the wallet network during loading.</p> <pre><code>let network = Network::Signet;\nlet file_path = \"test_wallet.sqlite3\";\nlet mut conn = rusqlite::Connection::open(file_path)?;\n\nlet wallet_opt = Wallet::load()\n    .descriptor(KeychainKind::External, Some(EXTERNAL_DESCRIPTOR))\n    .descriptor(KeychainKind::Internal, Some(INTERNAL_DESCRIPTOR))\n    .extract_keys() // only needed if using private key descriptors\n    .check_network(network)\n    .load_wallet(&amp;mut conn)?;\n</code></pre> <p>If during wallet loading no wallet database file is found you can create a sqlite-based persisted wallet with <code>Wallet::create()</code> with a valid db connection and other wallet builder parameters:</p> <pre><code>let mut wallet = match wallet_opt {\n    Some(wallet) =&gt; {\n        println!(\"Loaded existing wallet database.\");\n        wallet\n    }\n    None =&gt; {\n        println!(\"Creating new wallet database.\");\n        Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n            .network(network)\n            .create_wallet(&amp;mut conn)?\n    }\n};\n</code></pre> <p>After performing an operation that returns data that should be persisted, use the <code>persist()</code> method on the wallet:</p> <pre><code>// Reveal a new address from your external keychain\nlet address = wallet.reveal_next_address(KeychainKind::External);\nwallet.persist(&amp;mut conn)?;\n// Only share new address with user after successfully persisting wallet\nprintln!(\"Wallet address[{}]: {}\", address.index, address.address);\n</code></pre> <p></p>"},{"location":"cookbook/syncing/electrum/","title":"Sync a Wallet with Electrum","text":"<p>Syncing with Electrum uses what we refer to as SPK-based syncing (see our Full Scan vs Sync page for more information on this).</p> <p>The workflow for a full scan or sync consists of a 3-step process:</p> <ol> <li>Ask the wallet for the data structure required.</li> <li>Pass it to your blockchain client and request a full scan or sync.</li> <li>The client returns an update, which you then apply to the wallet.</li> </ol> <p>This workflow ensures that the wallet structure is not blocked while the syncing operation is performed.</p>"},{"location":"cookbook/syncing/electrum/#add-required-bdk-dependencies-to-your-cargotoml-file","title":"Add required bdk dependencies to your <code>Cargo.toml</code> file","text":"Cargo.toml<pre><code>[dependencies]\nbdk_wallet = { version = \"1.0.0\" }\nbdk_electrum = { version = \"0.20.1\" }\n</code></pre>"},{"location":"cookbook/syncing/electrum/#create-and-sync-the-wallet","title":"Create and sync the wallet","text":"main.rs<pre><code>use bdk_electrum::electrum_client::Client;\nuse bdk_electrum::{electrum_client, BdkElectrumClient};\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::AddressInfo;\nuse bdk_wallet::KeychainKind;\nuse bdk_wallet::Wallet;\n\nconst STOP_GAP: usize = 50;\nconst BATCH_SIZE: usize = 5;\nconst EXTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/0/*)#g9xn7wf9\";\nconst INTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/1/*)#e3rjrmea\";\n\nfn main() {\n    let mut wallet: Wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n        .network(Network::Signet)\n        .create_wallet_no_persist()\n        .unwrap();\n\n    let address: AddressInfo = wallet.reveal_next_address(KeychainKind::External);\n    println!(\n        \"Generated address {} at index {}\",\n        address.address, address.index\n    );\n\n    // Create the Electrum client\n    let client: BdkElectrumClient&lt;Client&gt; =\n        BdkElectrumClient::new(electrum_client::Client::new(\"ssl://mempool.space:60602\").unwrap());\n\n    // Perform the initial full scan on the wallet\n    let full_scan_request = wallet.start_full_scan();\n    let update = client\n        .full_scan(full_scan_request, STOP_GAP, BATCH_SIZE, true)\n        .unwrap();\n\n    wallet.apply_update(update).unwrap();\n    let balance = wallet.balance();\n    println!(\"Wallet balance: {} sat\", balance.total().to_sat());\n}\n</code></pre>"},{"location":"cookbook/syncing/esplora/","title":"Sync a Wallet with Esplora","text":"<p>Syncing with Esplora uses what we refer to as SPK-based syncing (see our Full Scan vs Sync page for more information on this).</p> <p>The workflow for a full scan or sync consists of a 3-step process:</p> <ol> <li>Ask the wallet for the data structure required.</li> <li>Pass it to your blockchain client and request a full scan or sync.</li> <li>The client returns an update, which you then apply to the wallet.</li> </ol> <p>This workflow ensures that the wallet structure is not blocked while the syncing operation is performed.</p>"},{"location":"cookbook/syncing/esplora/#add-required-bdk-dependencies-to-your-cargotoml-file","title":"Add required bdk dependencies to your Cargo.toml file","text":"Cargo.toml<pre><code>[dependencies]\nbdk_wallet = { version = \"1.0.0\" }\nbdk_esplora = { version = \"0.20.1\", features = [\"blocking\"] }\nanyhow = \"1\"\n</code></pre>"},{"location":"cookbook/syncing/esplora/#create-and-sync-the-wallet","title":"Create and sync the wallet","text":"main.rs<pre><code>use anyhow::Error;\nuse bdk_esplora::esplora_client::Builder;\nuse bdk_esplora::{esplora_client, EsploraExt};\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::chain::spk_client::{\n    FullScanRequestBuilder, FullScanResponse, SyncRequestBuilder, SyncResponse,\n};\nuse bdk_wallet::AddressInfo;\nuse bdk_wallet::KeychainKind;\nuse bdk_wallet::Wallet;\n\nconst STOP_GAP: usize = 50;\nconst PARALLEL_REQUESTS: usize = 1;\nconst EXTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/0/*)#g9xn7wf9\";\nconst INTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/1/*)#e3rjrmea\";\n\nfn main() -&gt; Result&lt;(), Error&gt; {\n    let mut wallet: Wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n        .network(Network::Signet)\n        .create_wallet_no_persist()?;\n\n    let address: AddressInfo = wallet.reveal_next_address(KeychainKind::External);\n    println!(\n        \"Generated address {} at index {}\",\n        address.address, address.index\n    );\n\n    //--8&lt;-- [start:client]\n    // Create the Esplora client\n    let client: esplora_client::BlockingClient =\n        Builder::new(\"http://signet.bitcoindevkit.net\").build_blocking();\n    //--8&lt;-- [end:client]\n\n    //--8&lt;-- [start:scan]\n    // Full scan the wallet\n    let full_scan_request: FullScanRequestBuilder&lt;KeychainKind&gt; = wallet.start_full_scan();\n    let full_scan_response: FullScanResponse&lt;KeychainKind&gt; =\n        client.full_scan(full_scan_request, STOP_GAP, PARALLEL_REQUESTS)?;\n\n    // Apply the full scan response to the wallet\n    wallet.apply_update(full_scan_response)?;\n    //--8&lt;-- [end:scan]\n\n    //--8&lt;-- [start:sync]\n    // Sync the wallet\n    let sync_request: SyncRequestBuilder&lt;(KeychainKind, u32)&gt; =\n        wallet.start_sync_with_revealed_spks();\n    let sync_response: SyncResponse = client.sync(sync_request, PARALLEL_REQUESTS)?;\n\n    // Apply the sync response to the wallet\n    wallet.apply_update(sync_response)?;\n    //--8&lt;-- [end:sync]\n\n    let balance = wallet.balance();\n    println!(\"Wallet balance: {} sat\", balance.total().to_sat());\n\n    Ok(())\n}\n</code></pre>"},{"location":"cookbook/syncing/full-scan-vs-sync/","title":"Full Scan vs Sync","text":"<p>Two of the four blockchain client libraries maintained by BDK (Electrum and Esplora) use what we refer to as SPK-based syncing (as opposed to block-by-block syncing). This SPK-based syncing relies on two concepts we call Full Scan and Sync. This page explains the difference between the two, the tradeoffs made when choosing each, and recommendations on when to use them.</p>"},{"location":"cookbook/syncing/full-scan-vs-sync/#full-scan","title":"Full Scan","text":"<p>A full scan is an operation that aims to build a complete picture of a wallet's UTXOs from scratch, with no prior data or knowledge about the wallet. It involves querying the blockchain data client for ScriptPubKeys that the wallet owns, typically at a number of indices on the wallet's keychains. </p> <p>Because the wallet doesn't know which scripts/addresses have been given out and potentially have funds associated with them, it needs to query the blockchain client for a group of addresses, see if any of those have balances, and keep asking for more until a number of addresses in a row for each keychain are unused (the exact number is configurable and is what's typically known as a stop gap). The operation also returns a new chain tip the wallet uses to update its <code>LocalChain</code>.</p> <p>A full scan is needed in cases where the wallet is unknown and is not loaded from persistence.</p>"},{"location":"cookbook/syncing/full-scan-vs-sync/#sync","title":"Sync","text":"<p>A sync is a related operation which can be thought of as \"catching up\" on the latest things that have happened on the chain since the last full scan or sync. A sync only makes sense if the list of addresses given out is known, and will query the blockchain data client for those scripts only. It also returns a new chain tip the wallet uses to update its <code>LocalChain</code>.</p> <p>A sync is a smaller and more optimal operation than a full scan, and should often be used in cases after an initial full scan has been performed.</p>"},{"location":"cookbook/syncing/full-scan-vs-sync/#practical-examples","title":"Practical Examples","text":"<p>Here are 4 different examples with wallets of different sizes and stop gap choices. The numbers in the Full Scan and Sync columns are the resulting number of scripts requested to the Electrum or Esplora instances.</p> Example Addr. Revealed Stop Gap Full Scan Sync A 7 20 27 7 B 7 1000 1007 7 C 500 20 520 500 D 500 1000 1500 500"},{"location":"cookbook/syncing/full-scan-vs-sync/#additional-considerations-server-load","title":"Additional Considerations \u2014 Server Load","text":"<p>Note that the choice of full scan vs sync as well as the stop gap on the wallet influences the load on the server infrastructure that services those requests. Whether these servers are maintained by you or you are using publicly available servers, understanding those choices is important.</p> <p>In particular, the difference between a full scan and a sync depends on your choice of stop gap and the current size of the wallet like so:</p> <ol> <li>If the stop gap is small, the difference between your sync and full scan will be smaller than if the stop gap is very big. Wallets A and B above have revealed 7 addresses each, yet wallet B's full scan is more than 100x its sync while wallet A's is only 4x. Using a sync on wallet B will make a big difference on your server load (particularly if you sync often).</li> <li>The difference between the full scan and sync diminishes the bigger the wallet becomes. On a very small wallet (wallets A and B above), the stop gap makes a big part of the number of SPKs synced, whereas for bigger wallets , the stop gap makes up a much smaller percentage of the total number of SPKs synced. For example on wallet C (big wallet but small stop gap) the difference between the full scan and the sync is minimal.</li> </ol>"},{"location":"cookbook/syncing/full-scan-vs-sync/#additional-considerations-sync-but-not-always","title":"Additional Considerations \u2014 Sync, But Not Always!","text":"<p>We can think of a sync as a more narrow but optimized approach to syncing. It works really well for some situations, but is less applicable as a \"one-worklflow-to-rule-them-all\". In particular, wallets where the user might also be using their descriptors on other software can create problems with the sync workflow, since the wallet is not aware that new addresses have been revealed, and will not include them in its sync request.</p> <p>Here are situations for which sync works and performs best:</p> <ul> <li>Cases where you know the user only uses their descriptors with the current wallet (for example if the user has specified this as a toggle in settings), and a full scan has already been performed once.</li> <li>Situations where you call your syncing workflow on a loop, and you can safely assume that you're the only user of the descriptors at any given time. For example if you loop on 15s intervals you could have your loop full scan on first iteration and sync on further iterations, with a full scan every X number of minutes/iterations.</li> </ul> <p>Production applications need either a mix of both (and if so the option to trigger a full scan on user request, not just on first startup), or, if they want to only use one, use the full scan (to cover all cases and situations where users use their backups on different wallets/software).</p>"},{"location":"cookbook/syncing/full-scan-vs-sync/#additional-considerations-general-heuristics","title":"Additional Considerations \u2014 General Heuristics","text":"<p>The following heuristics work well for most standard wallets:</p> <ol> <li>If you are recovering a wallet which currently holds or has ever held a balance or are creating a wallet from scratch, your first syncing operation should be a full scan. This allows the wallet to discover which scripts have been used and create an accurate overall balance. If your sofware is certain that the users is only using their descriptors with this wallet, all other syncing operations can be sync.</li> <li>If you are loading a wallet from persistence for which a full scan has already been performed and related data has been persisted, your syncing operations can be sync. If you believe some addresses have been revealed in the meantime, do a full scan on startup.</li> <li>If you are operating on a wallet which is shared with other entities which might reveal addresses, your local wallet and its <code>TxGraph</code> will not know about these revealed scripts. In this case, and if you suspect addresses might have been revealed, you should perform a full scan.</li> </ol>"},{"location":"cookbook/syncing/full-scan-vs-sync/#additional-considerations-really-big-wallets","title":"Additional Considerations \u2014 Really Big Wallets","text":"<p>On really big wallets, a custom, application-defined choice of which spks to sync at any given time/trigger is probably more appropriate.</p> <p>For example, if a wallet has 2500 addresss revealed and your application tries to stay on a 10s loop... it is not a good idea (and doesn't really make sense anyway) to try and sync it all on every iteration.</p> <p>Some pooling of the spks in different buckets would probably work best, and this would be defined at the application layer. Variables to include in the choice of which SPKs to sync would probably include last known transaction for the SPK and last time it was synced.</p> <p></p>"},{"location":"cookbook/syncing/kyoto/","title":"Sync a wallet with Kyoto","text":"<p>BIP157 and BIP158 define a protocol for light clients to sync with the Bitcoin network without downloading the entire set of blocks in the chain of most work. These proposals define compact block filters, which allow a client to download a small commitment for the scripts contained in each block. These commitments, or filters, may be checked for inclusion of scripts owned by a user. In the event of a match, the light client may download and verify a block indeed contains a relevant transaction. Syncing via compact block filters offers privacy advantages over other chain sources, as the nodes serving the blocks to the client are only aware that the client is interested in an entire block, which may contain thousands of transactions.</p> <p>One such implementation of this protocol is Kyoto, which is a node and client for compact block filter based syncing. The <code>bdk_kyoto</code> crate supports an integration between Kyoto and <code>bdk_wallet</code>, so developers using <code>bdk_wallet</code> have a simple option to provide privacy-preserving and memory-conservative wallet syncing for their users.</p> <p>The following example uses the <code>bdk_kyoto</code> crate to recover and update a <code>bdk_wallet</code> using compact block filters.</p>"},{"location":"cookbook/syncing/kyoto/#add-required-bdk-dependencies-to-your-cargotoml-file","title":"Add required bdk dependencies to your <code>Cargo.toml</code> file","text":"Cargo.toml<pre><code>[package]\nname = \"kyoto\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\nbdk_kyoto = \"0.7.0\"\nbdk_wallet = \"1.0.0\"\ntokio = { version = \"1.37\", features = [\"full\"], default-features = false }\ntracing = \"0.1\"\ntracing-subscriber = \"0.3\"\n</code></pre>"},{"location":"cookbook/syncing/kyoto/#create-and-sync-the-wallet","title":"Create and sync the wallet","text":"main.rs<pre><code>use bdk_kyoto::builder::LightClientBuilder;\nuse bdk_kyoto::{LightClient, LogSubscriber, WarningSubscriber};\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::{KeychainKind, Wallet};\nuse tokio::select;\n\nconst RECEIVE: &amp;str = \"tr([7d94197e/86'/1'/0']tpubDCyQVJj8KzjiQsFjmb3KwECVXPvMwvAxxZGCP9XmWSopmjW3bCV3wD7TgxrUhiGSueDS1MU5X1Vb1YjYcp8jitXc5fXfdC1z68hDDEyKRNr/0/*)\";\nconst CHANGE: &amp;str = \"tr([7d94197e/86'/1'/0']tpubDCyQVJj8KzjiQsFjmb3KwECVXPvMwvAxxZGCP9XmWSopmjW3bCV3wD7TgxrUhiGSueDS1MU5X1Vb1YjYcp8jitXc5fXfdC1z68hDDEyKRNr/1/*)\";\nconst RECOVERY_HEIGHT: u32 = 190_000;\nconst RECOVERY_LOOKAHEAD: u32 = 50;\nconst NUM_CONNECTIONS: u8 = 1;\n\n/// Implement a custom logger that prints log messages to the console.\nasync fn trace_logs(mut log_subscriber: LogSubscriber, mut warning_subscriber: WarningSubscriber) {\n    loop {\n        select! {\n            log = log_subscriber.next_log() =&gt; {\n                tracing::info!(\"{log}\")\n            }\n            warn = warning_subscriber.next_warning() =&gt; {\n                tracing::warn!(\"{warn}\")\n            }\n        }\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    // Initialize tracing\n    let subscriber = tracing_subscriber::FmtSubscriber::new();\n    tracing::subscriber::set_global_default(subscriber).unwrap();\n\n    // Apply the recovery lookahead to the wallet\n    let mut wallet = Wallet::create(RECEIVE, CHANGE)\n        .network(Network::Signet)\n        .lookahead(RECOVERY_LOOKAHEAD)\n        .create_wallet_no_persist()\n        .unwrap();\n\n    // Build a node that will find and connect to peers, gather relevant blocks, and broadcast transactions.\n    // In addition, receive a client that allows for communication with a running node to receive wallet\n    // updates, relay transactions to the node, and get updates on the node's actions.\n    let LightClient {\n        requester,\n        log_subscriber,\n        warning_subscriber,\n        mut update_subscriber,\n        node,\n    } = LightClientBuilder::new()\n        .scan_after(RECOVERY_HEIGHT)\n        .connections(NUM_CONNECTIONS)\n        .build(&amp;wallet)\n        .unwrap();\n\n    // Run the node on a separate task. The node will run continuously until instructed by the client\n    // to stop. The node will attempt to stay in sync with its peers by listening for messages as long\n    // as the application is running.\n    tokio::task::spawn(async move { node.run().await });\n\n    // Trace the logs with a custom function.\n    tokio::task::spawn(async move { trace_logs(log_subscriber, warning_subscriber).await });\n\n    // Sync and apply updates to the wallet. We can do this a continual loop while the application is running.\n    // Often this would occur on a separate thread than the underlying application user interface.\n    loop {\n        // Wait for an update from the client, if there is one.\n        if let Some(update) = update_subscriber.update().await {\n            wallet.apply_update(update).unwrap();\n            tracing::info!(\"Tx count: {}\", wallet.transactions().count());\n            tracing::info!(\"Balance: {}\", wallet.balance().total().to_sat());\n            let last_revealed = wallet.derivation_index(KeychainKind::External).unwrap();\n            tracing::info!(\"Last revealed External: {}\", last_revealed);\n            tracing::info!(\n                \"Last revealed Internal: {}\",\n                wallet.derivation_index(KeychainKind::Internal).unwrap()\n            );\n            tracing::info!(\"Local chain tip: {}\", wallet.local_chain().tip().height());\n            let next = wallet.peek_address(KeychainKind::External, last_revealed + 1);\n            tracing::info!(\"Next receiving address: {next}\");\n            requester.add_script(next.address).await.unwrap();\n            break;\n        }\n    }\n}\n</code></pre>"},{"location":"cookbook/syncing/kyoto/#a-note-on-unconfirmed-transactions-recoveries-sync-and-full-scan","title":"A note on unconfirmed transactions, recoveries, sync and full-scan","text":"<p>The entire set of scripts is checked against each block filter as new blocks are gossiped to the Kyoto node. Because the scripts are not checked iteratively, there is not a semantic difference between \"sync\" and \"full scan\". Rather, Kyoto is made aware of the <code>lookahead</code> number of scripts ahead of the last revealed index for each keychain in the wallet when the node is built. To recover a wallet, the <code>lookahead</code> should be set to a number greater than or equal to the number of scripts revealed by the wallet. Developers can and should add scripts to check for filter inclusions by calling <code>add_script</code> when transactions are built or addresses are revealed.</p> <p>Unconfirmed transactions pose a problem for light clients, as connections are untrusted. As such, users will be unaware of transactions they have received until they are confirmed in a block. While this tradeoff may be cumbersome, the benefits may outweigh the costs for privacy-conscious users.</p>"},{"location":"cookbook/syncing/rpc/","title":"Sync a Wallet with Bitcoin Core RPC","text":""},{"location":"cookbook/syncing/rpc/#1-start-a-regtest-bitcoin-daemon","title":"1. Start a regtest bitcoin daemon","text":"<p>For this example you'll need to run a bitcoin core daemon locally in regtest mode. Here are some of the commands you'll need: <pre><code># In a shell dedicated to the bitcoin daemon \nbitcoind --chain=regtest\n\n# In a new shell dedicated to the bitcoin-cli\nbitcoin-cli --chain=regtest getblockchaininfo\n\nbitcoin-cli --chain=regtest createwallet mywallet\nbitcoin-cli --chain=regtest loadwallet mywallet\nbitcoin-cli --chain=regtest getnewaddress\n\n# Mine 101 blocks\nbitcoin-cli --chain=regtest generatetoaddress 101 &lt;address&gt;\n\n# Send to address\nbitcoin-cli --chain=regtest sendtoaddress &lt;address&gt; &lt;amount&gt;\n</code></pre></p>"},{"location":"cookbook/syncing/rpc/#2-create-a-new-rust-project","title":"2. Create a new Rust project","text":"<pre><code>cargo init rpcexample\ncd rpcexample\n</code></pre>"},{"location":"cookbook/syncing/rpc/#3-add-required-bdk-dependencies-to-your-cargotoml-file","title":"3. Add required bdk dependencies to your <code>Cargo.toml</code> file","text":"Cargo.toml<pre><code>[package]\nname = \"rpc\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nbdk_wallet = { version = \"1.0.0\" }\nbdk_bitcoind_rpc = {  version = \"0.17.1\" }\n</code></pre>"},{"location":"cookbook/syncing/rpc/#4-create-your-descriptors","title":"4. Create your descriptors","text":"<p>Refer to the Working with Descriptors page for information on how to generate descriptors. This page will assume you are working on Regtest with the following BIP86 descriptors: <pre><code>const EXTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/0/*)#g9xn7wf9\";\nconst INTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/1/*)#e3rjrmea\";\n</code></pre></p>"},{"location":"cookbook/syncing/rpc/#5-create-and-sync-wallet","title":"5. Create and sync wallet","text":"main.rs<pre><code>use bdk_bitcoind_rpc::bitcoincore_rpc::{Auth, Client, RpcApi};\nuse bdk_bitcoind_rpc::Emitter;\nuse bdk_wallet::bitcoin::{Network, Transaction};\nuse bdk_wallet::chain::local_chain::CheckPoint;\nuse bdk_wallet::{AddressInfo, Balance, KeychainKind, Wallet};\n\nconst COOKIE_FILE_PATH: &amp;str = \"&lt;path_to_your_regtest_bitcoin_core_data_dir&gt;/.cookie\";\nconst EXTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/0/*)#g9xn7wf9\";\nconst INTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/1/*)#e3rjrmea\";\n\nfn main() {\n    let mut wallet: Wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n        .network(Network::Regtest)\n        .create_wallet_no_persist()\n        .unwrap();\n\n    let balance: Balance = wallet.balance();\n    println!(\"Wallet balance before syncing: {}\", balance.total());\n\n    let address: AddressInfo = wallet.reveal_next_address(KeychainKind::External);\n    println!(\n        \"Generated address {} at index {}\",\n        address.address, address.index\n    );\n\n    let rpc_client: Client = Client::new(\n        \"http://127.0.0.1:18443\",\n        // Auth::UserPass(\"__cookie__\".to_string(), \"cookievalue\".to_string())\n        Auth::CookieFile(COOKIE_FILE_PATH.into()),\n    )\n    .unwrap();\n\n    let blockchain_info = rpc_client.get_blockchain_info().unwrap();\n    println!(\n        \"\\nConnected to Bitcoin Core RPC.\\nChain: {}\\nLatest block: {} at height {}\\n\",\n        blockchain_info.chain, blockchain_info.best_block_hash, blockchain_info.blocks,\n    );\n\n    let wallet_tip: CheckPoint = wallet.latest_checkpoint();\n    println!(\n        \"Current wallet tip is: {} at height {}\",\n        &amp;wallet_tip.hash(),\n        &amp;wallet_tip.height()\n    );\n\n    let mut emitter = Emitter::new(&amp;rpc_client, wallet_tip.clone(), wallet_tip.height());\n\n    println!(\"Syncing blocks...\");\n    while let Some(block) = emitter.next_block().unwrap() {\n        print!(\"{} \", block.block_height());\n        wallet\n            .apply_block_connected_to(&amp;block.block, block.block_height(), block.connected_to())\n            .unwrap();\n    }\n    println!();\n\n    println!(\"Syncing mempool...\");\n    let mempool_emissions: Vec&lt;(Transaction, u64)&gt; = emitter.mempool().unwrap();\n    wallet.apply_unconfirmed_txs(mempool_emissions);\n\n    let balance: Balance = wallet.balance();\n    println!(\"Wallet balance after syncing: {}\", balance.total());\n}\n</code></pre> <p>Once you have synced the wallet once, mine a few new blocks using the bitcoin-cli and send coins to the address provided by the wallet and printed in the console. Upon running the example code again, your wallet will sync up the latest blocks and update its balance.</p>"},{"location":"cookbook/transactions/transaction-builder/","title":"Transaction Builder","text":"<p>The Transaction Builder provides a convenient way to construct bitcoin transactions by offering a builder-type API that helps developers manage the typical requirements for building transactions: recipients, fees, signatures, and a whole lot more.</p>"},{"location":"cookbook/transactions/transaction-builder/#features","title":"Features","text":"<ul> <li>Flexible Input and Output Selection: You can add or subtract inputs and outputs as needed.</li> <li>Fees: The builder calculates and adds fees automatically based on a specified fee rate or absolute target.</li> <li>Finalization: The builder helps finalize the transaction, ensuring signatures and other conditions are met.</li> </ul>"},{"location":"cookbook/transactions/transaction-builder/#usage","title":"Usage","text":"<p>To start building a new transaction, instantiate the <code>TxBuilder</code> type provided by BDK by calling the <code>Wallet::build_tx()</code> method. On this builder you chain various methods to add inputs, outputs, and configure other settings. Finally, call <code>TxBuilder::finish()</code> to get a PSBT ready for signing.</p> <pre><code>let psbt = wallet.build_tx()\n    .add_recipient(address.script_pubkey(), amount)\n    .finish()?;\n</code></pre>"},{"location":"cookbook/transactions/transaction-builder/#customizing-outputs","title":"Customizing Outputs","text":"<p>You can specify multiple recipients for the transaction, distributing funds across various addresses. The output is added as a script with an amount:</p> <pre><code>wallet.build_tx()\n    .add_recipient(to_address1.script_pubkey(), amount1)\n    .add_recipient(to_address2.script_pubkey(), amount2)\n</code></pre>"},{"location":"cookbook/transactions/transaction-builder/#choosing-inputs","title":"Choosing Inputs","text":"<p>You can manually select specific UTXOs, as well as request to not spend specific UTXOs:</p> <pre><code>wallet.build_tx()\n    .add_utxo(utxo1)?\n    .add_unspendable(utxo2)\n    .add_recipient(address.script_pubkey(), amount)\n</code></pre> <p>Combining the above with <code>TxBuilder::manually_selected_only</code> will ensure that the wallet only spends UTXOs specified by the <code>TxBuilder::add_utxo</code> method.</p> <p>Alternatively, let the wallet choose the inputs:</p> <pre><code>wallet.build_tx()\n    .add_recipient(address.script_pubkey(), amount)\n</code></pre>"},{"location":"cookbook/transactions/transaction-builder/#fee-management","title":"Fee Management","text":"<p>The builder allows you to define a fee rate or an absolute fee:</p> <pre><code>wallet.build_tx()\n    .fee_rate(FeeRate::from_sat_per_vb(4))\n    .fee_absolute(Amount::from_sat(600))\n</code></pre> <p>Note that if you set the fee using both the fee_absolute and the fee_rate method, the wallet will use method was called last, as the fee rate and the absolute fee amount are mutually exclusive.</p>"},{"location":"cookbook/transactions/transaction-builder/#spend-all-funds","title":"Spend all funds","text":"<p>The transaction builder has a convenience method that will spend all UTXOs available to it (while respecting the unspendable UTXOs if any). Simple use of this method will simply increase the size of your change output, but you can combine it with the <code>TxBuilder::drain_to</code> method to ensure all funds are sent to a specific address:</p> <pre><code>let mut tx_builder = wallet.build_tx();\ntx_builder.drain_wallet();\ntx_builder.drain_to(faucet_address.script_pubkey());\n</code></pre>"},{"location":"cookbook/transactions/transaction-builder/#set-the-nsequence-value","title":"Set the nSequence value","text":"<p>The <code>TxBuilder::set_exact_sequence</code> method allows users to set their nSequence value directly. This is also the way you would disable signaling for RBF, as the TxBuilder will by default enable it.</p> <pre><code>wallet.build_tx()\n    .add_recipient(address.script_pubkey(), amount)\n    .set_exact_sequence(sequence)\n</code></pre>"},{"location":"cookbook/transactions/transaction-builder/#finalizing-the-psbt","title":"Finalizing the PSBT","text":"<p>Once you\u2019ve added inputs, outputs, and calculated the fees, you can build the psbt using the <code>TxBuilder::finish</code> method.</p> <pre><code>let psbt = wallet.build_tx()\n    .finish()?;\n</code></pre> <p>The result is a PSBT ready to be signed and later on broadcast to the network.</p>"},{"location":"cookbook/transactions/transaction-builder/#signing-the-psbt-and-extracting-the-transaction","title":"Signing the PSBT and extracting the transaction","text":"<p>Sign the PSBT using the <code>Wallet::sign</code> method and extract the finalized transaction from it using the Psbt::extract_tx` method for a ready-to-be-broadcast transaction.</p> <pre><code>wallet.sign(&amp;mut psbt, SignOptions::default())?;\nlet tx = psbt.extract_tx()?;\n</code></pre>"},{"location":"getting-started/3rd-party-bindings/","title":"3rd Party Bindings","text":"<p>Some organizations are maintaining their own wrappers and language bindings around the BDK libraries. While these are not maintained by the Foundation, they have users in production and are worth looking into!</p>"},{"location":"getting-started/3rd-party-bindings/#wasm","title":"WASM","text":"<p>bdk-wasm</p> <p>Note: The bdk-wasm lib can be used in just about any modern JavaScript environment, including Browser, Node, ReactNative, etc.</p>"},{"location":"getting-started/3rd-party-bindings/#flutter","title":"Flutter","text":"<p>bdk-flutter</p>"},{"location":"getting-started/3rd-party-bindings/#reactnative","title":"ReactNative","text":"<p>bdk-rn</p> <p>Note: the <code>bdk-wasm</code> lib also works for ReactNative.</p>"},{"location":"getting-started/api-documentation/","title":"API Documentation","text":"<p>Our API documentation is available here:</p> <ul> <li>bdk_wallet</li> <li>bdk_chain</li> <li>bdk_file_store</li> <li>bdk_electrum</li> <li>bdk_esplora</li> <li>bdk_bitcoind_rpc</li> <li>bdk_hwi</li> <li>esplora-client</li> <li>electrum-client</li> </ul>"},{"location":"getting-started/build-a-wallet/","title":"I Want To Build A Wallet Using BDK","text":"<p>So you want to build a bitcoin wallet using BDK. Great! Here is the rough outline of what you need to do just that. A standard, simple example of a bitcoin wallet in BDK-land would require 3 core pillars:</p> <ol> <li>The <code>bdk_wallet</code> library, which will provide two core types: the <code>Wallet</code> and the <code>TxBuilder</code>. This library will handle all the domain logic related to keeping track of which UTXOs you own, what your total balance is, creating and signing transactions, etc.</li> <li>A blockchain client. Your wallet will need to keep track of blockchain data, like new transactions that have been added to the blockchain that impact your wallet, requesting these transactions to a Bitcoin Core node, an Electrum or Esplora server, etc.</li> <li>A persistence mechanism for saving wallet data between sessions (note that this is not actually required). Things like which addresses the wallet has revealed and what is the state of the blockchain on its last sync are things that are kept in persistence and can be loaded on startup.</li> </ol> The 3 core pieces of a BDK wallet."},{"location":"getting-started/getting-started/","title":"Getting Started","text":"<p>Notice</p> <p>This book is up-to-date with version <code>1.0.0</code> of the <code>bdk_wallet</code> rust library.</p>"},{"location":"getting-started/getting-started/#install-rust","title":"Install Rust","text":"<p>See the Rust Getting Started page to install the Rust development tools.</p>"},{"location":"getting-started/getting-started/#using-bdk-in-a-rust-project","title":"Using BDK in a Rust project","text":"<p>Follow these steps to use BDK in your own rust project with the <code>electrum</code> blockchain client.</p> <ol> <li>Create a new Rust project:</li> </ol> <pre><code>cargo init my_bdk_app\ncd my_bdk_app\n</code></pre> <ol> <li>Add <code>bdk_wallet</code> to your <code>Cargo.toml</code> file. Find the latest <code>bdk_wallet</code> release on crates.io, for example:</li> </ol> <pre><code>cargo add bdk_wallet@1.0.0\n</code></pre> <ol> <li>Add other required dependencies:</li> </ol> <pre><code>cargo add bdk_electrum@0.20.1\n</code></pre> <p>Follow the Sync a Wallet with Electrum page for a simple example of how to create and sync a wallet.</p>"},{"location":"getting-started/migrating/","title":"Migrating from 0.X","text":"<p>So you're ready to migrate to BDK version 1.0, congratulations! This document contains some helpful tips that, with the help of some automation, should make the process as seamless as possible.</p> <p>The below steps are for migrating wallet details from the old <code>bdk</code> v0.30 to the new <code>bdk_wallet</code> v1.0. This procedure can be applied to wallets backed by a SQLite database.</p> <p>To migrate your wallet data to a new version of bdk, essentially all you need to do is grab the last known address index for each keychain from the old db, add them to the new db, and sync to refetch the rest of the data. Doing this means we don't need to perform a full scan because we already have the indexes (doing a full scan would check for used addresses based on the stop gap which is unnecessary).</p> <p>This migration is important because without that metadata the new wallet may end up reusing receive addresses, which should be avoided for privacy reasons, although it should not cause loss of funds.</p> <p>Tip</p> <p>NB: The migration process outlined below will not automatically restore the wallet's transaction data or local view of the blockchain. Thanks to the public ledger however, we can restore all the pertinent information for this wallet using one of the blockchain client libraries supported by BDK.</p>"},{"location":"getting-started/migrating/#overview","title":"Overview","text":"<ol> <li>Load an old database</li> <li>Get last revealed addresses</li> <li>Create new wallet</li> <li>Restore revealed addresses</li> <li>Write to new database</li> <li>Sync</li> </ol> examples/rust/migrate-version/src/main.rs<pre><code>fn main() -&gt; anyhow::Result&lt;()&gt; {\n    // Open old wallet\n    let db = SqliteDatabase::new(BDK_DB_PATH);\n    let old_wallet = bdk::Wallet::new(\n        EXTERNAL_DESCRIPTOR,\n        Some(INTERNAL_DESCRIPTOR),\n        bdk::bitcoin::Network::Testnet,\n        db,\n    )?;\n\n    // Get last revealed addresses for each keychain\n    let addr = old_wallet.get_address(AddressIndex::LastUnused)?;\n    println!(\"Last revealed external {} {}\", addr.index, addr.address);\n    let external_derivation_index = addr.index;\n    let last_revealed_external = addr.address.to_string();\n\n    let addr = old_wallet.get_internal_address(AddressIndex::LastUnused)?;\n    println!(\"Last revealed internal {} {}\", addr.index, addr.address);\n    let internal_derivation_index = addr.index;\n    let last_revealed_internal = addr.address.to_string();\n\n    // Create new wallet\n    let mut db = rusqlite::Connection::open(BDK_WALLET_DB_PATH)?;\n    let mut new_wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n        .network(NETWORK)\n        .create_wallet(&amp;mut db)\n        .context(\"failed to create wallet\")?;\n\n    // Retore revealed addresses\n    let _ = new_wallet.reveal_addresses_to(KeychainKind::External, external_derivation_index);\n    let _ = new_wallet.reveal_addresses_to(KeychainKind::Internal, internal_derivation_index);\n\n    // Persist new wallet\n    new_wallet.persist(&amp;mut db)?;\n\n    println!(\"\\n========== New database created. ==========\");\n\n    let addr = new_wallet\n        .list_unused_addresses(KeychainKind::External)\n        .last()\n        .unwrap();\n    assert_eq!(addr.to_string(), last_revealed_external);\n    println!(\"Last revealed external {} {}\", addr.index, addr.address);\n    let addr = new_wallet\n        .list_unused_addresses(KeychainKind::Internal)\n        .last()\n        .unwrap();\n    println!(\"Last revealed internal {} {}\", addr.index, addr.address);\n    assert_eq!(addr.to_string(), last_revealed_internal);\n\n    Ok(())\n}\n</code></pre>"},{"location":"getting-started/migrating/#walkthrough","title":"Walkthrough","text":"<p>In a new rust project add these dependencies to Cargo.toml</p> Cargo.toml<pre><code>[dependencies]\nanyhow = \"1\"\nbdk = { version = \"0.30\", features = [\"sqlite\"] }\nbdk_wallet = { version = \"1.0.0\", features = [\"rusqlite\"] }\n</code></pre> <p>Because there are two versions of bdk in the same project, we need to pay attention to how types are imported. To avoid name clashes or any sort of mismatch resolving types that appear similar, we use fully qualified syntax, for example <code>bdk::bitcoin::Network::Testnet</code>. You'll notice in some cases we can get around this annoyance by casting a value to another rust primitive or standard library type such as <code>String</code>.</p> examples/rust/migrate-version/src/main.rs<pre><code>use anyhow::Context;\n\nuse bdk::database::SqliteDatabase;\nuse bdk::wallet::AddressIndex;\n\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::rusqlite;\nuse bdk_wallet::KeychainKind;\nuse bdk_wallet::Wallet;\n</code></pre> <p>Take a minute to define a few constants, for example the file path to the current database and the path to be used for the new database. The descriptors and network shown here are for illustration; you should substitute them with your own. Note that because we'll be creating a fresh database there should not already exist a persisted wallet at the new path.</p> examples/rust/migrate-version/src/main.rs<pre><code>const EXTERNAL_DESCRIPTOR: &amp;str = \"wpkh(tprv8ZgxMBicQKsPdy6LMhUtFHAgpocR8GC6QmwMSFpZs7h6Eziw3SpThFfczTDh5rW2krkqffa11UpX3XkeTTB2FvzZKWXqPY54Y6Rq4AQ5R8L/84'/1'/0'/0/*)\";\nconst INTERNAL_DESCRIPTOR: &amp;str = \"wpkh(tprv8ZgxMBicQKsPdy6LMhUtFHAgpocR8GC6QmwMSFpZs7h6Eziw3SpThFfczTDh5rW2krkqffa11UpX3XkeTTB2FvzZKWXqPY54Y6Rq4AQ5R8L/84'/1'/0'/1/*)\";\nconst NETWORK: Network = Network::Testnet;\n\n// path to old db\nconst BDK_DB_PATH: &amp;str = \"./.bdk-example.sqlite\";\n// path to new db\nconst BDK_WALLET_DB_PATH: &amp;str = \"./.bdk-wallet-example.sqlite\";\n</code></pre> <p>Now retrieve the last revealed addresses from the <code>old_wallet</code>.</p> examples/rust/migrate-version/src/main.rs<pre><code>// Open old wallet\nlet db = SqliteDatabase::new(BDK_DB_PATH);\nlet old_wallet = bdk::Wallet::new(\n    EXTERNAL_DESCRIPTOR,\n    Some(INTERNAL_DESCRIPTOR),\n    bdk::bitcoin::Network::Testnet,\n    db,\n)?;\n\n// Get last revealed addresses for each keychain\nlet addr = old_wallet.get_address(AddressIndex::LastUnused)?;\nprintln!(\"Last revealed external {} {}\", addr.index, addr.address);\nlet external_derivation_index = addr.index;\nlet last_revealed_external = addr.address.to_string();\n\nlet addr = old_wallet.get_internal_address(AddressIndex::LastUnused)?;\nprintln!(\"Last revealed internal {} {}\", addr.index, addr.address);\nlet internal_derivation_index = addr.index;\nlet last_revealed_internal = addr.address.to_string();\n</code></pre> <p>For the <code>new_wallet</code> we should be using the same descriptors and network as before. If the given descriptors contain secret keys, then the wallet will be able to sign transactions as well.</p> examples/rust/migrate-version/src/main.rs<pre><code>// Create new wallet\nlet mut db = rusqlite::Connection::open(BDK_WALLET_DB_PATH)?;\nlet mut new_wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n    .network(NETWORK)\n    .create_wallet(&amp;mut db)\n    .context(\"failed to create wallet\")?;\n\n// Retore revealed addresses\nlet _ = new_wallet.reveal_addresses_to(KeychainKind::External, external_derivation_index);\nlet _ = new_wallet.reveal_addresses_to(KeychainKind::Internal, internal_derivation_index);\n\n// Persist new wallet\nnew_wallet.persist(&amp;mut db)?;\n\nprintln!(\"\\n========== New database created. ==========\");\n\nlet addr = new_wallet\n    .list_unused_addresses(KeychainKind::External)\n    .last()\n    .unwrap();\nassert_eq!(addr.to_string(), last_revealed_external);\nprintln!(\"Last revealed external {} {}\", addr.index, addr.address);\nlet addr = new_wallet\n    .list_unused_addresses(KeychainKind::Internal)\n    .last()\n    .unwrap();\nprintln!(\"Last revealed internal {} {}\", addr.index, addr.address);\nassert_eq!(addr.to_string(), last_revealed_internal);\n</code></pre> <p>Now that we have a new database and have properly restored our addresses, you will want to sync with the blockchain to recover the wallet's transactions. Below is an example of doing a <code>sync</code> using <code>bdk_esplora</code> but the exact method of syncing will depend on your application. Remember we don't need to do a full scan here since we already have the indexes.</p> examples/rust/migrate-version/src/main.rs<pre><code>use bdk_esplora::{esplora_client, EsploraExt};\n\nlet client = esplora_client::Builder::new(ESPLORA_URL).build_blocking();\n\nlet request = wallet\n    .start_sync_with_revealed_spks()\n    .inspect(|item, prog| {\n        if let SyncItem::Spk(index, script) = item {\n            let address = Address::from_script(script, NETWORK).unwrap();\n            let progress = prog.consumed() as f32 / prog.total() as f32;\n            eprintln!(\"[ SYNCING {:.2}% ] {:?} {}\", 100.0 * progress, index, address);\n            std::io::stdout().flush().unwrap();\n        }\n    });\n\nlet update = client.sync(request, PARALLEL_REQUESTS)?;\n\nwallet.apply_update(update)?;\nwallet.persist(&amp;mut db)?;\n</code></pre> <p>Happy migrating and see you on v1.0!</p>"},{"location":"getting-started/more-bdk/","title":"More Places to Find BDK Content","text":"<p>Here are some other places you can find BDK-related content:</p>"},{"location":"getting-started/more-bdk/#youtube","title":"Youtube","text":"<ul> <li>The Bitcoin Developers channel has a series of videos on BDK.</li> <li>Building on BDK with Ben Carman, Alekos Filini &amp; Steve Myers</li> </ul>"},{"location":"getting-started/more-bdk/#podcasts","title":"Podcasts","text":"<ul> <li>Alekos and Daniela on the Chaincode Podcast</li> </ul>"},{"location":"getting-started/more-bdk/#awesome-list","title":"Awesome List","text":"<ul> <li>We maintain an Awesome List for BDK.</li> </ul>"},{"location":"getting-started/organization/","title":"Project Organization","text":"<p>Within the <code>bitcoindevkit</code> GitHub organization, the BDK team maintains a suite of Rust crates which provide both easy-to-use high level APIs and powerful lower level components to use when building more advanced bitcoin software.</p>"},{"location":"getting-started/organization/#source-code","title":"Source Code","text":"<p>The core project is split up into several crates in the <code>bdk/crates</code> directory:</p> <ul> <li><code>bdk_wallet</code>: Contains the central high level <code>Wallet</code> type    that is built from the low-level mechanisms provided by the other components.</li> <li><code>bdk_chain</code>: Tools for storing and indexing chain data.</li> <li><code>bdk_file_store</code>: A persistence backend for storing chain data in a single file.</li> <li><code>bdk_sqlite</code>: A simple SQLite relational database client for persisting bdk_chain data.</li> <li><code>bdk_esplora</code>: Extends the <code>esplora-client</code>    crate with methods to fetch chain data from an esplora HTTP server in the form that    <code>bdk_chain</code> and <code>Wallet</code> can consume.</li> <li><code>bdk_electrum</code>: Extends the <code>electrum-client</code>    crate with methods to fetch chain data from an electrum server in the form that    <code>bdk_chain</code> and <code>Wallet</code> can consume.</li> </ul>"},{"location":"getting-started/why-book/","title":"Who Is This Book For?","text":"<p>The purpose of this book is to give a strong overview of the Bitcoin Development Kit family of libraries and how they can be used together to build production-grade bitcoin applications. We aim to provide a good understanding of how to leverage our libraries together, expose the options available to developers in terms of blockchain clients and persistence layers, as well as ways they can go deeper into lower-level crates if their needs are not met by the high-level APIs exposed in the <code>bdk_wallet</code> library.</p> <p>Finally, the book is meant to get developers up to speed on general concepts pertaining to the BDK architecture as well as concrete examples of how to use our APIs in the different languages for which we provide language bindings libraries.</p> <p>What this book is not:</p> <ul> <li>API documentation, nor a comprehensive listing of all APIs available in BDK libraries. We maintain API docs on all our libraries for that purpose.</li> <li>A place to learn about core bitcoin concepts (PSBTs, UTXOs, Electrum protocol, BIPs, etc.). We provide links to great resources on these topics where appropriate.</li> <li>A comprehensive treatment of the tradeoff space developers face when building bitcoin applications (Esplora protocol vs compact block filters, onchain vs layer 2s, secure elements on mobile devices, etc.).</li> </ul>"}]}